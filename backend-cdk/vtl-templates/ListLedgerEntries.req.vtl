## VTL Request Template for Query.listLedgerEntries
## Fetches ledger entries.
## - Non-admins see their own entries.
## - Admins can see entries for the owner specified in args.filter.owner.eq.
## - Includes simplified filter expression handling.

#set( $limit = $util.defaultIfNull($context.args.limit, 20) )

## Determine the owner for the DynamoDB query
#set( $ownerIdToQuery = $context.identity.sub )
#if( $context.identity.groups && $context.identity.groups.contains("Admin") )
  #if( $context.args.filter && $context.args.filter.owner && $context.args.filter.owner.eq && !$util.isNullOrEmpty($context.args.filter.owner.eq) )
    #set( $ownerIdToQuery = $context.args.filter.owner.eq )
  #end
#end

#if( $util.isNullOrEmpty($ownerIdToQuery) )
  $util.error("Owner ID for query is null or empty. This should not happen if user is authenticated.", "InvalidRequestException")
#end

## Expression attributes setup
#set( $expressionNames = {} )
#set( $expressionValues = {} )
$util.qr($expressionNames.put("#ownerAttribute", "owner"))
$util.qr($expressionValues.put(":ownerValue", $util.dynamodb.toDynamoDB($ownerIdToQuery)))
#set( $keyConditionExpression = "#ownerAttribute = :ownerValue" )

## Logging
$util.qr($ctx.log.info("LEDGER_VTL_REQ: Effective Owner for Query: $ownerIdToQuery"))

## Build base query object
#set( $queryObj = {
  "version": "2018-05-29",
  "operation": "Query",
  "index": "byOwner",
  "query": {
    "expression": $keyConditionExpression,
    "expressionNames": $expressionNames,
    "expressionValues": $expressionValues
  },
  "limit": $limit,
  "scanIndexForward": false
})

## Handle pagination
#if( $context.args.nextToken && !$util.isNullOrBlank($context.args.nextToken) )
  $util.qr($queryObj.put("nextToken", $context.args.nextToken))
#end

## Optional filters
#if( $context.args.filter )
  #set( $filterExpressionParts = [] )

  ## Filter by type
  #if( $context.args.filter.type && $context.args.filter.type.eq && !$util.isNullOrBlank($context.args.filter.type.eq) )
    $util.qr($filterExpressionParts.add("#filterLedgerEntryType = :filterLedgerEntryType"))
    $util.qr($expressionNames.put("#filterLedgerEntryType", "type")) 
    $util.qr($expressionValues.put(":filterLedgerEntryType", $util.dynamodb.toDynamoDB($context.args.filter.type.eq)))
  #end

  ## Filter by createdAt range
  #if( $context.args.filter.createdAt && $context.args.filter.createdAt.between && $context.args.filter.createdAt.between.size() == 2 )
    $util.qr($filterExpressionParts.add("#filterCreatedAt BETWEEN :startRange AND :endRange"))
    $util.qr($expressionNames.put("#filterCreatedAt", "createdAt"))
    $util.qr($expressionValues.put(":startRange", $util.dynamodb.toDynamoDB($context.args.filter.createdAt.between[0])))
    $util.qr($expressionValues.put(":endRange", $util.dynamodb.toDynamoDB($context.args.filter.createdAt.between[1])))
  #end

  ## Attach the combined filter expression
  #if( !$filterExpressionParts.isEmpty() )
    $util.qr($queryObj.put("filter", {
      "expression": $util.listJoin(" AND ", $filterExpressionParts)
    }))
  #end
#end

## Final logging
$util.qr($ctx.log.info("LEDGER_VTL_REQ: Final DynamoDB Query Object: $util.toJson($queryObj)"))
$util.toJson($queryObj)
