## VTL Request Template for Query.listLedgerEntries
## Fetches ledger entries based on owner, supports pagination.
## Differentiates between admin and non-admin users for owner filtering.
## Includes DEBUGGING LOGS.

#set( $limit = $util.defaultIfNull($context.args.limit, 20) )
#set( $nextToken = $util.defaultIfNullOrBlank($context.args.nextToken, null) )

## Log initial context information
$util.log.info("VTL_DEBUG --- ListLedgerEntries ---")
$util.log.info("VTL_DEBUG: Logged-in User - Username: " + $util.toJson($context.identity.username))
$util.log.info("VTL_DEBUG: Logged-in User - Sub (Identity): " + $util.toJson($context.identity.sub))
$util.log.info("VTL_DEBUG: Logged-in User - Cognito Groups: " + $util.toJson($context.identity.groups))
$util.log.info("VTL_DEBUG: GraphQL Arguments (context.args): " + $util.toJson($context.args))
#if( $context.args.filter )
  $util.log.info("VTL_DEBUG: context.args.filter.owner: " + $util.toJson($context.args.filter.owner))
  #if( $context.args.filter.owner )
    $util.log.info("VTL_DEBUG: context.args.filter.owner.eq: " + $util.toJson($context.args.filter.owner.eq))
  #end
#end

#set( $ownerIdToQuery = $context.identity.sub ) ## Default to logged-in user's sub
$util.log.info("VTL_DEBUG: Initial ownerIdToQuery (defaulted to logged-in user's sub): " + $util.toJson($ownerIdToQuery))

#set( $isAdminUser = false )
#if( $context.identity.groups && $context.identity.groups.contains("Admin") ) ## Ensure 'Admin' matches your Cognito Group name exactly
  #set( $isAdminUser = true )
  $util.log.info("VTL_DEBUG: User IS considered an Admin (member of 'Admin' group).")
  #if( $context.args.filter && $context.args.filter.owner && $context.args.filter.owner.eq && !$util.isNullOrEmpty($context.args.filter.owner.eq) )
    $util.log.info("VTL_DEBUG: Admin provided a specific owner filter: " + $util.toJson($context.args.filter.owner.eq))
    #set( $ownerIdToQuery = $context.args.filter.owner.eq )
  #else
    $util.log.info("VTL_DEBUG: Admin did NOT provide a specific owner filter, or it was empty. Query will use admin's own sub: " + $util.toJson($ownerIdToQuery) + ". (This part of the logic means admin sees their own data if no filter is passed)")
    ## If admin MUST provide a filter to see other users' data for this specific query:
    ## $util.error("Admin users must specify an owner filter to list entries for another user.", "ValidationException")
  #end
#else
  $util.log.info("VTL_DEBUG: User is NOT considered an Admin (not in 'Admin' group or no groups). Forcing ownerIdToQuery to user's own sub.")
  ## For non-admins, $ownerIdToQuery is already $context.identity.sub. No change needed here.
#end

$util.log.info("VTL_DEBUG: FINAL ownerIdToQuery being used for DynamoDB query: " + $util.toJson($ownerIdToQuery))

#if( $util.isNullOrEmpty($ownerIdToQuery) )
  $util.error("VTL_DEBUG_ERROR: ownerIdToQuery is null or empty. Cannot proceed with DynamoDB query.", "InvalidRequestException")
#end

#set( $dynamoDBQuery = {
  "version": "2018-05-29",
  "operation": "Query",
  "index": "byOwner",
  "query": {
    "expression": "#ownerAttribute = :ownerValue",
    "expressionNames": {
      "#ownerAttribute": "owner" ## This is the actual attribute name in your DynamoDB table GSI
    },
    "expressionValues": {
      ":ownerValue": $util.dynamodb.toDynamoDBJson($ownerIdToQuery)
    }
  },
  "limit": $limit,
  "scanIndexForward": false ## Optional: Sorts by sort key descending (e.g., newest first if sort key is a timestamp)
                           ## Remove or set to true for ascending. Requires a sort key on the GSI.
})

#if( $nextToken )
  #set( $dynamoDBQuery.nextToken = $nextToken ) ## $nextToken is already a string from $context.args
#end

## Optional: Add further filter expressions if needed from $context.args.filter
## This example shows how to add a date range filter for a 'createdAt' attribute.
## Ensure 'createdAt' exists and is an ISO8601 string for this to work.
#if( $context.args.filter && $context.args.filter.createdAt && $context.args.filter.createdAt.between && $context.args.filter.createdAt.between.size() == 2 )
    #if( $dynamoDBQuery.filter )
        #set( $dynamoDBQuery.filter.expression = $dynamoDBQuery.filter.expression + " AND (#createdAtTime BETWEEN :startRange AND :endRange)" )
    #else
        #set( $dynamoDBQuery.filter = {
            "expression": "#createdAtTime BETWEEN :startRange AND :endRange",
            "expressionNames": {}, 
            "expressionValues": {} 
        } )
    #end
    #if( !$dynamoDBQuery.filter.expressionNames ) ## Ensure expressionNames exists
        #set( $dynamoDBQuery.filter.expressionNames = {} )
    #end
    #set( $dynamoDBQuery.filter.expressionNames["#createdAtTime"] = "createdAt" ) ## Actual attribute name for createdAt
    
    #if( !$dynamoDBQuery.filter.expressionValues ) ## Ensure expressionValues exists
        #set( $dynamoDBQuery.filter.expressionValues = {} )
    #end
    #set( $dynamoDBQuery.filter.expressionValues[":startRange"] = $util.dynamodb.toDynamoDBJson($context.args.filter.createdAt.between[0]) )
    #set( $dynamoDBQuery.filter.expressionValues[":endRange"] = $util.dynamodb.toDynamoDBJson($context.args.filter.createdAt.between[1]) )
#end

$util.log.info("VTL_DEBUG: Final DynamoDB Query Object to be executed: " + $util.toJson($dynamoDBQuery))

$dynamoDBQuery