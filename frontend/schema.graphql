# Schema for Sales Ledger Application - Updated 2038 31052025

# --- Enums ---
enum LedgerEntryType {
  INVOICE
  CREDIT_NOTE
  INCREASE_ADJUSTMENT
  DECREASE_ADJUSTMENT
  CASH_RECEIPT # Note: This type is used by LedgerEntry but created by adminAddCashReceipt for CurrentAccountTransaction
}

enum CurrentAccountTransactionType {
  PAYMENT_REQUEST
  CASH_RECEIPT
}

# --- Object Types (Your Data Models) ---
type LedgerEntry {
  id: ID!
  owner: String! # Cognito User Sub ID
  type: LedgerEntryType!
  amount: Float!
  description: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  createdByAdmin: String # Optional: ID of admin if created by admin
}

type AccountStatus {
  id: ID! # Typically the owner's Cognito User Sub ID
  owner: String! # Cognito User Sub ID
  totalUnapprovedInvoiceValue: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  createdByAdmin: String # Optional: ID of admin if created/updated by admin
}

type CurrentAccountTransaction {
  id: ID!
  owner: String! # Cognito User Sub ID
  type: CurrentAccountTransactionType!
  amount: Float!
  description: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  createdByAdmin: String # Optional: ID of admin if created by admin
}

type UserAttribute {
  name: String!
  value: String
}

type CognitoUser {
  username: String!
  sub: String!
  status: String
  enabled: Boolean
  createdAt: AWSDateTime
  updatedAt: AWSDateTime # This was in your query, renamed from lastModifiedAt for consistency if preferred
  attributes: [UserAttribute]

  # --- ADDED/UPDATED FIELDS ---
  id: ID!                # Often maps to Cognito 'sub' or 'Username'. Ensure your Lambda provides this.
  email: String            # Ensure your Lambda extracts and provides this.
  lastModifiedAt: AWSDateTime # Ensure your Lambda provides this (from UserLastModifiedDate).
  groups: [String]         # Ensure your Lambda fetches and provides this.
  # --- END ADDED/UPDATED FIELDS ---
}

# --- NEW: Structured Result Type for Admin Payment Request ---
type AdminPaymentRequestResult {
  success: Boolean!
  message: String
  transactionId: ID # Optional ID of a transaction created (e.g., PAYMENT_REQUEST in CurrentAccountTransactionTable)
}

# --- Connection Types for List Operations ---
type LedgerEntryConnection {
  items: [LedgerEntry]
  nextToken: String
}

type AccountStatusConnection {
  items: [AccountStatus]
  nextToken: String
}

type CurrentAccountTransactionConnection {
  items: [CurrentAccountTransaction]
  nextToken: String
}

type UserListResult {
  users: [CognitoUser] # Make sure this list returns CognitoUser type
  nextToken: String
}

# --- Input Types for Mutations ---
input CreateLedgerEntryInput {
  type: LedgerEntryType!
  amount: Float!
  description: String
}

input UpdateLedgerEntryInput {
  id: ID!
  type: LedgerEntryType
  amount: Float
  description: String
}

input UpdateAccountStatusInput {
  id: ID! # Should be the ID (sub) of the user whose status is being updated
  totalUnapprovedInvoiceValue: Float! # Made non-optional as per your previous VTL
}

# --- Input Type for Admin Creating Ledger Entry for a User ---
input AdminCreateLedgerEntryInput {
  type: LedgerEntryType!
  amount: Float!
  description: String
  targetUserId: ID! # The user for whom this entry is being created
}

# --- Input Type for Admin Requesting Payment for a User ---
input AdminRequestPaymentForUserInput {
  targetUserId: ID!
  amount: Float!
  paymentDescription: String # Example of an additional field
}

# --- NEW: Input Type for sendPaymentRequestEmail ---
input SendPaymentRequestInput {
  amount: Float!
  # Add other fields if needed in the future
}

# --- NEW: Input Type for adminCreateAccountStatus ---
input AdminCreateAccountStatusInput {
  # ownerId: ID! # Assuming 'id' of AccountStatus is auto-generated or is the Cognito sub if that's the PK design
  accountId: ID! # If AccountStatus items are uniquely identified by an accountId separate from its own 'id'
                 # Or if 'id' of AccountStatus *is* the accountId/ownerId, this might be redundant
                 # Based on AdminCreateAccountStatus.req.vtl, it seems 'id' is auto-generated for AccountStatus,
                 # and 'accountId' (from input) and 'owner' (admin's sub) are stored.
  initialUnapprovedInvoiceValue: Float!
  status: String! # Added based on AdminCreateAccountStatus.req.vtl needing a status
}

# --- NEW: Input Type for adminAddCashReceipt ---
input AdminAddCashReceiptInput {
  targetOwnerId: ID! # The owner the cash receipt is for
  amount: Float!
  description: String
  # receiptDate: AWSDateTime # Optional: if client can specify, otherwise server sets it
}


# --- Input Types for Query Filters (Enhanced ModelStringFilterInput) ---
input ModelStringFilterInput {
  eq: String
  ne: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String] # Array of two strings for date/string range
  beginsWith: String
}

input ModelIDFilterInput {
  eq: ID
  ne: ID
}

input ModelFloatFilterInput {
  eq: Float
  ne: Float
  gt: Float
  lt: Float
  ge: Float
  le: Float
}

input LedgerEntryFilterInput {
  id: ModelIDFilterInput
  owner: ModelStringFilterInput
  type: ModelStringFilterInput # Can now filter by LedgerEntryType string value
  createdAt: ModelStringFilterInput # Now supports range queries via 'between', 'gt', etc.
}

input AccountStatusFilterInput {
  id: ModelIDFilterInput
  owner: ModelStringFilterInput # This is likely the Cognito Sub of the status record owner
  # If you want to filter by the account an AccountStatus pertains to,
  # ensure you have a queryable 'accountId' field in your AccountStatus DDB table and add it here.
  totalUnapprovedInvoiceValue: ModelFloatFilterInput
  createdAt: ModelStringFilterInput
}

input CurrentAccountTransactionFilterInput {
  id: ModelIDFilterInput
  owner: ModelStringFilterInput
  type: ModelStringFilterInput # Can now filter by CurrentAccountTransactionType string value
  createdAt: ModelStringFilterInput
}

# --- Query Type ---
type Query @aws_cognito_user_pools {

  getLedgerEntry(id: ID!): LedgerEntry
  listLedgerEntries(filter: LedgerEntryFilterInput, limit: Int, nextToken: String): LedgerEntryConnection

  getAccountStatus(id: ID!): AccountStatus
  listAccountStatuses(filter: AccountStatusFilterInput, limit: Int, nextToken: String): AccountStatusConnection # Removed 'owner: String' arg as filter handles it

  getCurrentAccountTransaction(id: ID!): CurrentAccountTransaction
  listCurrentAccountTransactions(filter: CurrentAccountTransactionFilterInput, limit: Int, nextToken: String): CurrentAccountTransactionConnection

  adminListUsers(limit: Int, nextToken: String, filter: UserFilterInput): UserListResult # Added UserFilterInput for consistency
    @aws_auth(cognito_groups: ["Admin"])
}

# --- NEW: UserFilterInput for adminListUsers ---
input UserFilterInput {
  # Define fields your Lambda can filter by, e.g.:
  username: ModelStringFilterInput
  email: ModelStringFilterInput
  status: ModelStringFilterInput
  # group: String # Example if filtering by a single group name
}

# --- Mutation Type ---
type Mutation @aws_cognito_user_pools {

  # LedgerEntry mutations
  createLedgerEntry(input: CreateLedgerEntryInput!): LedgerEntry
  updateLedgerEntry(input: UpdateLedgerEntryInput!): LedgerEntry
  deleteLedgerEntry(id: ID!): LedgerEntry # Consider returning a status/confirmation type

  adminCreateLedgerEntry(input: AdminCreateLedgerEntryInput!): LedgerEntry
    @aws_auth(cognito_groups: ["Admin"])

  # AccountStatus Mutations
  updateAccountStatus(input: UpdateAccountStatusInput!): AccountStatus
    # Removed @aws_auth(cognito_groups: ["Admin"]) - VTL handles owner check; if only admin, add back
  adminCreateAccountStatus(input: AdminCreateAccountStatusInput!): AccountStatus
    @aws_auth(cognito_groups: ["Admin"])

  # CurrentAccountTransaction Admin Mutation
  adminAddCashReceipt(input: AdminAddCashReceiptInput!): CurrentAccountTransaction
    @aws_auth(cognito_groups: ["Admin"])

  # Payment Request Mutations
  sendPaymentRequestEmail(input: SendPaymentRequestInput!): String # Consider a status type
  adminRequestPaymentForUser(input: AdminRequestPaymentForUserInput!): AdminPaymentRequestResult
    @aws_auth(cognito_groups: ["Admin"])
}

# --- Subscription Type ---
type Subscription @aws_cognito_user_pools {
  onCreateLedgerEntry(owner: String): LedgerEntry
    @aws_subscribe(mutations: ["createLedgerEntry", "adminCreateLedgerEntry"])
}